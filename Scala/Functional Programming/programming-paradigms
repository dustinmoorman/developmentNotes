Programming Paradigms
====================

Paradigm: In science, a paradigm describes distinct concepts
or thought patterns in some scientific discipline.

Main programming paradigms:
	- imperative programming
	- functional programming
	- logic programming

Orthogonal to it:
	- object-oriented programming

Object Oriented programming can be integrated with functional 
programming, it follows the imperative programming paradigm
traditionally.

Review: Imperative programming

Imperative programming is about
	- modifying mutable variables,
	- using assignments
	- and control structures such as if-then-else, loops, 
	  break, continue, return

The most common informal way to understand imperative programs 
is as instruction sequences for a Von Neumann computer.

Imperative Programs and Computers

There's a strong correspondence between
	Mutable variables	=>	memory cells
	Variable dereferences	=>	load instructions
	Variable assignments	=>	store instructions
	Control structures	=>	jumps

Problem: Scaling up. How can we avoid conceptualizing programs
word by word?

Reference: John Backus, Can Programming Be Liberated from the
von Neumann Style? Turing Award Lecture 1978.

John Backus invented Fortran in the 1950's.

He noted that imperative programming was running out of steam. 

In the end, pure imperative programming is limited by the "Von
Neumann" bottleneck.
	
	>> One tends to conceptualize data structures word-by-word.

We need other techniques for defining high-level abstractions 
such as collections, polynomials, geometric shapes, strings, 
documents. 

Ideally: Develop 'theories' of collections, shapes, strings.

What is a Theory?

A theory consists of 
	- one or more data types
	- operations on these types
	- laws that describe the relationships between
	  values and operations

Normally, a theory in mathematics does not describe mutations!

Theories without Mutation

For instance, the theory of polynomials defines the sum of 
two polynomials by laws such as:

	(a*x + b) + (c*x + d) = (a+c)*x + (b+d)

But it does not define an operator to change a coefficient while
keeping the polynomial the same!

Whereas in an imperative program, one can write:

	class Polynomial { double[] coefficient ; }

	Polynomial p = ...;
	
	p.coefficient[0] = 42;

The theory of strings defines a concatenation operator ++ which is
associative:

	(a ++ b) ++ c = a ++ (b ++ c)

But it does not define an operator to change a sequence element
while keeping the sequence the same!

(This one, some languages do get right; e.g. Java's strings are immutable)

//1.1 6:43
